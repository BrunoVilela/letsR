resultado <- cbind(x$S, media)
colnames(resultado) <- c("Species", "Value")
return(as.data.frame(resultado))
}
fiel <- lets.field(resu1, resu2[, 6], resu2[, 1])
fiel
lets.field <- function(x, y, z, weigth=T){
if(is.factor(y)){
y <- as.numeric(levels(y))[y]
}
p <- x$P[, -(1:2)]
p2 <- p
for(i in 1:ncol(p2)){
pos <- which(x$S[i]==z)
if(length(pos)>0){
p2[, i] <- p2[, i]*y[pos]
pos2 <- which(p2[, i]==0)
p2[pos2, i] <- NA
}else{
p2[, i] <- NA
}
}
media <- numeric(ncol(p))
for(i in 1:length(media)){
pos3 <- p[, i]==1
p3 <- p[pos3, -i]
p4 <- p2[pos3, -i]
mult <- p3*p4
if(weigth==T){
media[i] <- mean(mult, na.rm=T)
}
if(weigth==F){
me <- colMeans(mult, na.rm=T)
media[i] <- mean(me, na.rm=T)
}
}
resultado <- cbind(x$S, media)
colnames(resultado) <- c("Species", "Value")
return(as.data.frame(resultado))
}
fiel <- lets.field(resu1, resu2[, 6], resu2[, 1])
fiel
cor(resu2[, 6], fiel[, 2])
cor(as.numeric(levels(resu2[, 6]))[resu2[, 6]], fiel[, 2])
cor(as.numeric(levels(resu2[, 6]))[resu2[, 6]], as.numeric(levels(fiel[, 2]))[fiel[, 2]])
library(letsR)
#Packages
library(raster)
library(maptools)
library(maps)
library(XML)
devtools::load_all(".")
amphi <- readShapePoly("C:/Users/Bruno/Documents/Spatial data/All_AMPHIBIANS_NOV2013/All_AMPHIBIANS_NOV2013.shp", delete_null_obj=TRUE)
resu <- lets.presab(amphi, resol=1, remove.cell=T, remove.sp=T)
resu_iuc <- lets.iucn(resu1)
risco <- lets.iucncont(resu1[, 3])
resu_iuc <- lets.iucn(resu)
risco <- lets.iucncont(resu_iuc[, 3])
valor <- lets.field(resu, risco, resu_iuc)
cor(risco, valor)
risco
valor
which(is.na(risco) | is.na(valor))
ret <- which(is.na(risco) | is.na(valor))
cor(risco[-ret], valor[-ret])
valor
ret <- which(is.na(risco) | is.na(valor[,2]))
cor(risco[-ret], valor[-ret,2])
class(valor[,2])
class(risco)
valor[,2] <- as.numeric(levels(valor[,2]))[valor[,2]]
class(valor[,2])
ret <- which(is.na(risco) | is.na(valor[,2]))
cor(risco[-ret], valor[-ret,2])
plot(risco[-ret], valor[-ret,2])
barplot(risco[-ret], valor[-ret,2])
boxplot(risco[-ret], valor[-ret,2])
valor
risco
boxplot(risco[-ret], valor[-ret,2])
plot(risco[-ret], valor[-ret,2])
lm(valor ~ risco)
lm(valor~risco)
lm(valor[-ret,2]~risco[-ret])
modelo <- lm(valor[-ret,2]~risco[-ret])
summar(modelo)
summary(modelo)
modelo <- lm(valor[-ret,2]~as.factor(risco[-ret]))
summary(modelo)
plot(valor[-ret,2]~as.factor(risco[-ret]))
head(resu_iuc)
resu_iuc[,6] <- as.numeric(levels(resu_iuc[,6]))[resu_iuc[,6]]
modelo <- lm(as.factor(risco[-ret])~valor[-ret,2])
modelo <- lm(risco[-ret]~valor[-ret,2])
modelo
summary(modelo)
modelo <- lm(risco[-ret]~valor[-ret,2]+resu_iuc[-ret,6])
modelo <- lm(risco[-ret]~valor[-ret,2]+resu_iuc[-ret,6])
summary(modelo)
modelo <- lm(risco[-ret]~valor[-ret,2]+resu_iuc[-ret,6]+resu_iuc[-ret,2])
summary(modelo)
class(resu_iuc[-ret,2])
modelo <- lm(risco[-ret]~valor[-ret,2]+resu_iuc[-ret,6]+resu_iuc[-ret,2])
summary(modelo)
cor(risco[-ret],valor[-ret,2])
?as.data.frame
library(XML)
reptiledb<-function(input){
unlist(strsplit(input, ' '))->a
h <- try(htmlParse(paste("http://reptile-database.reptarium.cz/species?genus=",a[1],"&species=",a[2], sep = "")),silent=TRUE)
test<-try(xpathSApply(h, '//h1', xmlValue),silent=TRUE)
return(year)
reptiledb2<-function(inputs){
resu<-numeric(nrow(inputs))
inputs<-as.matrix(inputs)
for(i in 1:length(inputs)){
}
as.numeric(gsub("\\D", "", test))->year
print(i)
reptiledb(inputs[i,])->resu[i]
}
colnames(resultado)<-c("Species","Description year")
}
reptiledb2(c("Bothrops andianus", "Bothrops muriciensis", "Ameiva ameiva"))
cbind(inputs,resu)->resultado
#Example
return(resultado)
library(XML)
reptiledb<-function(input){
unlist(strsplit(input, ' '))->a
h <- try(htmlParse(paste("http://reptile-database.reptarium.cz/species?genus=",a[1],"&species=",a[2], sep = "")),silent=TRUE)
test<-try(xpathSApply(h, '//h1', xmlValue),silent=TRUE)
as.numeric(gsub("\\D", "", test))->year
return(year)
}
reptiledb2<-function(inputs){
inputs<-as.matrix(inputs)
resu<-numeric(nrow(inputs))
for(i in 1:length(inputs)){
print(i)
reptiledb(inputs[i,])->resu[i]
}
cbind(inputs,resu)->resultado
colnames(resultado)<-c("Species","Description year")
return(resultado)
}
reptiledb2(c("Bothrops andianus", "Bothrops muriciensis", "Ameiva ameiva"))
library(letsR)
devtools::load_all(".")
#Packages
library(raster)
library(maptools)
library(maps)
library(XML)
mama <- readShapePoly("C:/Users/Bruno/Documents/Spatial data/TERRESTRIAL_MAMMALS_NOV2013/TERRESTRIAL_MAMMALS_NOV2013.shp")
?lets.maplizer
library(letsR)
?lets.maplizer
?lets.iucn
library(letsR)
?letsR
library(devtools)
install_dev("https://github.com/BrunoVilela/letsR")
install_git("https://github.com/BrunoVilela/letsR")
library(letsR)
?lets.maplizer
resu_iuc <- lets.iucn(resu)
resu <- lets.presab(mama, resol=1, remove.cell=T, remove.sp=T)
resu_iuc <- lets.iucn(resu)
risco <- lets.iucncont(resu_iuc[, 3])
mapliz <- lets.maplizer(resu, risco, resu_iuc[, 1], ras=T)
plot(mapliz[[2]])
plot(mapliz[[2]], col=heat.colors(max(mapliz[[1]][,2])))
plot(mapliz[[2]], col=rev(heat.colors(max(mapliz[[1]][,2]))))
plot(resu)
summary(resu)
valor <- lets.field(resu, risco, resu_iuc[, 1])
valor
head(valor)
summary(valor)
summary(valor)->tes
names(tes)
tes
slotnames(tes)
slotNames(tes)
tes[1]
tes[2]
tes[2, ]
class(tes)
cor(resu_iuc[, 3], risco)
cor(valor, risco)
cor(valor[,2], risco)
ret <- which(is.na(risco) | is.na(valor[,2]))
cor(valor[-ret,2], risco[-ret])
hist(valor[-ret,2], risco[-ret])
barplot(valor[-ret,2], risco[-ret])
plot(valor[-ret,2], risco[-ret])
plot(round(valor[-ret,2]), risco[-ret])
barplot(as.factor(round(valor[-ret,2])), as.factor(risco[-ret]))
plot(as.factor(round(valor[-ret,2])), as.factor(risco[-ret]))
barplot(as.factor(round(valor[-ret,2])), as.factor(risco[-ret]))
barplot((valor[-ret,2]), as.factor(risco[-ret]))
barplot(valor[-ret,2], as.factor(risco[-ret]))
plot(valor[-ret,2], as.factor(risco[-ret]))
plot(valor[-ret,2]~ as.factor(risco[-ret]))
valor2 <- lets.field(resu, risco, resu_iuc[, 1], weigth=F)
ret <- which(is.na(risco) | is.na(valor2[,2]))
valor2 <- lets.field(resu, risco, resu_iuc[, 1], weigth=F)
x<-resu
y<-risco
z<-resu_iuc[,1]
weigth=F
z
if(is.factor(y)){
y <- as.numeric(levels(y))[y]
}
p <- x$P[, -(1:2)]
p2 <- p
for(i in 1:ncol(p2)){
pos <- which(z==x$S[i])
if(length(pos)>0){
p2[, i] <- p2[, i]*y[pos]
pos2 <- which(p2[, i]==0)
p2[pos2, i] <- NA
}else{
p2[, i] <- NA
}
}
media <- numeric(ncol(p))
for(i in 1:length(media)){
pos3 <- p[, i]==1
p3 <- p[pos3, -i]
p4 <- p2[pos3, -i]
mult <- p3*p4
if(weigth==T){
media[i] <- mean(mult, na.rm=T)
}
if(weigth==F){
me <- colMeans(mult, na.rm=T)
media[i] <- mean(me, na.rm=T)
}
}
i=1
pos3 <- p[, i]==1
p3 <- p[pos3, -i]
p4 <- p2[pos3, -i]
mult <- p3*p4
mult
colMeans(mlt)
colMeans(mult)
colMeans(mult, na.rm=T)
if(weigth==F){
me <- colMeans(mult, na.rm=T)
media[i] <- mean(me, na.rm=T)
}
for(i in 1:length(media)){
print(i)
pos3 <- p[, i]==1
p3 <- p[pos3, -i]
p4 <- p2[pos3, -i]
mult <- p3*p4
if(weigth==T){
media[i] <- mean(mult, na.rm=T)
}
if(weigth==F){
me <- colMeans(mult, na.rm=T)
media[i] <- mean(me, na.rm=T)
}
}
i=5
mult
me <- colMeans(mult, na.rm=T)
me <- mean(mult, na.rm=T)
me
class(mult)
as.matrix(mult)
ncol(p3)
ncol(p-1)
length(mult)
(ncol(p)-1)
as.matrix(mult, ncol=(ncol(p)-1))
matrix(mult, ncol=(ncol(p)-1))
matrix(1, 2, 2)
matrix(matrix(1, 2, 2), ncol=2)
matrix(matrix(1:4, 2, 2), ncol=2)
matrix(1:4, 2, 2)
#' Create variables based on species range field
#'
#' @author Bruno Vilela
#'
#' @description Create a variable based on other species values that cooccur in the geographic range.
#'
#' @usage lets.field(x, y, z, weigth=TRUE)
#'
#' @param x A PresenceAbsence object.
#' @param y Species atribute to be maped
#' @param z Species names in the same order of the atributes.
#' @param weigth If TRUE the value is weighted by species range cover,
#' if FASLSE the value is the mean of all species that cooccur with the
#'  species target.
#'
#' @return Return a matrix with species x values.
#'
#' @seealso lets.presab
#'
#' @export
lets.field <- function(x, y, z, weigth=T){
if(is.factor(y)){
y <- as.numeric(levels(y))[y]
}
p <- x$P[, -(1:2)]
p2 <- p
for(i in 1:ncol(p2)){
pos <- which(z==x$S[i])
if(length(pos)>0){
p2[, i] <- p2[, i]*y[pos]
pos2 <- which(p2[, i]==0)
p2[pos2, i] <- NA
}else{
p2[, i] <- NA
}
}
media <- numeric(ncol(p))
for(i in 1:length(media)){
print(i)
pos3 <- p[, i]==1
p3 <- p[pos3, -i]
p4 <- p2[pos3, -i]
mult <- p3*p4
if(weigth==T){
media[i] <- mean(mult, na.rm=T)
}
if(weigth==F){
mult <- matrix(mult, ncol=(ncol(p)-1))
me <- colMeans(mult, na.rm=T)
media[i] <- mean(me, na.rm=T)
}
}
resultado <- cbind(x$S, media)
colnames(resultado) <- c("Species", "Value")
resultado <- as.data.frame(resultado)
resultado[, 2] <- as.numeric(levels(resultado[, 2]))[resultado[, 2]]
return(resultado)
}
valor2 <- lets.field(resu, risco, resu_iuc[, 1], weigth=F)
head(valor2)
ret <- which(is.na(risco) | is.na(valor2[,2]))
cor(valor2[-ret,2], risco[-ret])
plot(valor2[-ret,2]~ as.factor(risco[-ret]))
anova(cor(valor2[-ret,2], risco[-ret]))
anova(valor2[-ret,2], risco[-ret])
devtools::load_all(".")
library(raster)
library(maps)
library(maptools)
library(XML)
lets.iucn("Pteronotropis welaka")
lets.iucn("Pteronotropis welaka")->resu
resu
?lets.iucn
lets.iucn("Pteronotropis welaka")->resu
?lets.iucn
library(letsR)
?lets.iucn
library("letsR", lib.loc="C:/Users/Bruno/Documents/R/win-library/3.0")
?lets.iucn
devtools::load_all(".")
library(letsR)
?lets.iucn
?letsR
lets.iucn("Pteronotropis welaka")->resu
?lets.iucn
devtools::load_all(".")
?lets.iucn
rm(list=ls())
library(letsR)
?lets.iucn
library(devtools)
install_github("BrunoVilela/letsR")
library(letsR)
install_github("BrunoVilela/letsR")
library(letsR)
?lets.presab
library(letsR)
#' Compute correlogram based on Moran's I
#'
#' @author Jos? Alexandre Diniz-Filho, Fabricio Villalobos, Lucas Jardim & Bruno Vilela
#'
#' @description Compute correlogram for a variable from a distance matrix.
#'
#' @usage lets.correl(x, y, z, equidistant=FALSE, plot=TRUE)
#'
#' @param x A single variable in a vector, or multiple variables in a matrix.
#' @param y A distance matrix.
#' @param z The number of distance classes in the correlogram.
#' @param equidistant Logical, if TRUE the classes will be equidistant. If FALSE the classes will be contruct to have equal number of pairs.
#' @param plot Logical, if TRUE the correlogram will be ploted.
#'
#' @import ape
#'
#' @export
lets.correl <- function(x, y, z, equidistant=FALSE, plot=TRUE){
if(is.vector(x)){
return(.br.correlogram(x, y, z, equidistant, plot))
}
if(!is.vector(x)){
n <- ncol(x)
parcial <- list()
for(i in 1:n){
parcial[[i]] <- .br.correlogram(x[, i], y, z, equidistant, plot=FALSE)[, c(1, 3, 5, 6)]
}
media <- apply(simplify2array(parcial), 1:2, mean)
desvio <- apply(simplify2array(parcial), 1:2, sd)
resu <- cbind(media[, 1], desvio[, 1], media[, 2], media[, 3], media[, 4] )
colnames(resu) <- c("Observed", "Standard_Deviation", "Expected_value", "Mean_Distance", "Count")
pos3 <- which(!is.na(media[, 1]))
if(plot==TRUE){
plot(x=resu[pos3, 4], y=resu[pos3, 1], bty="l",
ylab= "Moran's I", xlab= "Distance", type="l",
lty=3, ylim=c(-1.5, 1.5))
abline(h=mean(resu[pos3, 3]))
points(x=resu[pos3, 4], y=resu[pos3, 1], pch=20, cex=1.5)
epsilon = max(resu[pos3, 4])/(14*z)
for(i in 1:nrow(resu)) {
up <- resu[pos3, 1] + resu[pos3, 2]
low <- resu[pos3, 1] - resu[pos3, 2]
segments(resu[pos3, 4], low , resu[pos3, 4], up)
segments(resu[pos3, 4]-epsilon, up , resu[pos3, 4]+epsilon, up)
segments(resu[pos3, 4]-epsilon, low , resu[pos3, 4]+epsilon, low)
}
}
return(resu)
}
}
############
.br.correlogram <- function(x, y, z, equidistant=FALSE, plot=TRUE){
y3 <- y
diag(y3) <- NA
y2 <- y
z2 <- 1/z
if(equidistant==FALSE){
quant <- quantile(y3, probs=seq(0, 1, z2), na.rm = TRUE)
}
if(equidistant==TRUE){
quant <- seq(min(y), max(y), ((max(y)-min(y))/z))
}
quant <- as.vector(quant)
n <- length(quant)
ob <- rep(NA, (n-1))
sd1 <- rep(NA, (n-1))
ex <- rep(NA, (n-1))
dist_cl <- rep(NA, (n-1))
p <- rep(NA, (n-1))
count <- rep(NA, (n-1))
for(i in 1:(n-1)){
pos <- (y>quant[i] & y<=quant[i+1])
count[i] <- sum(pos)
dist_cl [i] <- mean(c(quant[i], quant[i+1]))
if(count[i]>0){
y2[pos] <- 1
y2[!pos] <- 0
m <- .br.moran(y2, x)
ob[i] <- m$observed
sd1[i] <- m$sd
ex[i] <- m$expected
dist_cl [i] <- mean(c(quant[i], quant[i+1]))
p[i] <- m$p.value
}
}
resu <- cbind(ob, sd1, ex, p, dist_cl, count)
colnames(resu) <- c("Observed", "Standard_Deviation", "Expected_value", "p_value", "Mean_Distance", "Count")
if(plot==TRUE){
pos3 <- which(!is.na(resu[, 1]))
plot(x=dist_cl[pos3],y=ob[pos3], bty="l",
ylab= "Moran's I", xlab= "Distance", type="l",
lty=3, ylim=c(-1.5, 1.5))
abline(h=mean(ex[pos3]))
points(x=dist_cl[pos3], y=ob[pos3], pch=20, cex=1.5)
epsilon = max(dist_cl[pos3])/(14*z)
for(i in 1:nrow(resu)) {
up <- resu[pos3, 1] + resu[pos3, 2]
low <- resu[pos3, 1] - resu[pos3, 2]
segments(resu[pos3, 5], low , resu[pos3, 5], up)
segments(resu[pos3, 5]-epsilon, up , resu[pos3, 5]+epsilon, up)
segments(resu[pos3, 5]-epsilon, low , resu[pos3, 5]+epsilon, low)
}
}
return(resu)
}
############
.br.moran <- function(w, y){
n <- sum(ifelse(rowSums(w)>0, 1, 0))
z <- y-mean(y)
soma <- n*(sum(w*(z%o%z)))
divi <- sum(w) * sum((z^2))
ob <- soma/divi
es <- -1/(n-1)
S1 <-  0.5 * sum((w + t(w))^2)
S2 <- sum((apply(w, 1, sum) + apply(w, 2, sum))^2)
k <- n*sum(z^4)/((sum(z^2))^2)
s.sq <- sum(w)^2
sdi <- sqrt((n * ((n^2 - 3 * n + 3) * S1 - n * S2 + 3 * s.sq)
- k * (n * (n - 1) * S1 - 2 * n * S2 + 6 * s.sq))/((n - 1) *
(n - 2) * (n - 3) * s.sq) - 1/((n - 1)^2))
pv <- pnorm(ob, mean = es, sd = sdi)
pv <- if (ob <= es)
2 * pv
else 2 * (1 - pv)
return(list("observed"=ob, "expected"=es, "sd"=sdi/sqrt(n), "p.value"= pv))
}
library(letsR)
lets.correl
