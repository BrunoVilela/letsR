xm <- numeric((n-2))
ym <- numeric((n-2))
for(i in 3:n){
pos <- which(pam2[,i]==1)
a <- max(pam2[pos, 1])
b <- min(pam2[pos, 1])
c <- max(pam2[pos, 2])
d <- min(pam2[pos, 2])
if(planar==F){
dis <- midPoint(c(a,c), c(b,d))
xm[(i-2)] <- dis[1, 1]
ym[(i-2)] <- dis[1, 2]
}
if(planar==T){
xm[(i-2)] <- mean(c(a,b))
ym[(i-2)] <- mean(c(c,d))
}
}
resu <- as.data.frame(cbind(species, xm, ym))
colnames(resu) <- c("Species", "x", "y")
xm
ym
a
b
c
d
ponto2 <- lets.midpoint(resu1, planar=F)
ponto2
ponto1 <- lets.midpoint(resu1, planar=T)
ponto1
ponto1
midPoint
.pointsToMatrix
.pointsToMatrix(p1)
pointsToMatrix
.pointsToMatrix
pointsToMatrix(p1) * toRad
data(teste)
mat <- lets.presab(teste)
pam <-mat$P
ponto1 <- lets.midpoint(resu1, planar=T)
ponto2 <- lets.midpoint(resu1, planar=F)
r <- raster()
values(r) <- 1
plot(r, col="white")
map(add=T)
ponto1 <- as.matrix(ponto1)
ponto2 <- as.matrix(ponto2)
points(x=as.numeric(ponto1[2,2]),y=as.numeric(ponto1[2,3]), cex=2, pch=20, col="purple")
points(x=as.numeric(ponto2[2,2]),y=as.numeric(ponto2[2,3]), cex=2, pch=20, col="red")
plot(mat, name=mat$S[2])
plot(resu1, name=mat$S[2])
plot(resu1, name=resu1$S[2])
points(x=as.numeric(ponto1[2,2]),y=as.numeric(ponto1[2,3]), cex=2, pch=20, col="purple")
points(x=as.numeric(ponto2[2,2]),y=as.numeric(ponto2[2,3]), cex=2, pch=20, col="red")
plot(resu1, name=resu1$S[1])
points(x=as.numeric(ponto1[1,2]),y=as.numeric(ponto1[1,3]), cex=2, pch=20, col="purple")
points(x=as.numeric(ponto2[1,2]),y=as.numeric(ponto2[1,3]), cex=2, pch=20, col="red")
plot(resu1, name=resu1$S[1])
points(x=as.numeric(ponto1[1,2]),y=as.numeric(ponto1[1,3]), cex=2, pch=20, col="purple")
points(x=as.numeric(ponto2[1,2]),y=as.numeric(ponto2[1,3]), cex=2, pch=20, col="green")
n=137000000
r=0.023
t=1975-1953
t
n0=137000000
r=0.023
t0=1975
t1=1953
cr <- function(n0, r, t0, t1){
t <- t1-t0
nt <- n0*exp((r*t))
return(nt)
}
cr(n0, r, t0, t1)
t <- t1-t0
t
t1
t <- t1-t0
t
t
t <- t1-t0
t
t1=1975
t0=1953
t <- t1-t0
t
nt <- n0*exp((r*t))
nt
N0 <- 1
tim <- 1:22
nt <- N0*l^tim
l <- r+1
N0 <- 1
tim <- 1:22
nt <- N0*l^tim
nt
nt <- n0*l^tim
nt
tim <- 0:22
nt <- n0*l^tim
nt
tim <- 0:23
nt <- n0*l^tim
nt
l <- r
tim <- 0:23
nt <- n0*l^tim
nt
dob <- function(r, mult){
t <- ln(mult)/r
return(t)
}
dob(r, 2)
dob <- function(r, mult){
t <- log(mult)/r
return(t)
}
dob(r, 2)
cr2 <- function(n0, lambda, t){
n <- n0*lambda^t
return(n)
}
cr2(n0, lambda, t)
lambda=1
n0=1000
lambda=1
t=3
cr2 <- function(n0, lambda, t){
n <- n0*lambda^t
return(n)
}
cr2(n0, lambda, t)
cr2 <- function(n0, lambda, t){
n <- n0*(lambda^t)
return(n)
}
cr2(n0, lambda, t)
100*0.111
source(1:1000, echo=T)
source(1:1000)
1:10000
1:100000
getOption(&quot;max.print&quot;)
options(max.print=10000)
1:100000
print(1:100000)
n=100
r=0.111
n*r
cr(n0, r, t0, 1954:1976)
n0=137000000
r=0.023
t1=1975
t0=1953
cr(n0, r, t0, 1954:1976)
plot(cr(n0, r, t0, 1954:1976))
plot(cr(n0, r, t0, 1954:2000))
plot(cr(n0, 2, t0, 1954:2000))
plot(cr(n0, 1, t0, 1954:2000))
plot(cr(n0, 0.4, t0, 1954:2000))
plot(cr(n0, 0.1, t0, 1954:2000))
#' Species geographical range midpoint
#'
#' @author Fabricio Villalobos & Bruno Vilela
#'
#' @description Get species geographical range midpoint from a presence-absence matrix.
#'
#' @usage lets.midpoint(pam, planar=FALSE)
#'
#' @param pam A presence absence matrix, or an object of class PresenceAbsence.
#' @param planar Logical, if FALSE the coordinates are in Longitude/Latitude. If TRUE the coordinates are planar.
#'
#' @return A matrix containing the point by species.
#'
#'
#' @import geosphere
#'
#' @seealso lets.presab
#'
#' @export
lets.midpoint <- function(pam, planar=FALSE){
if(class(pam)=="PresenceAbsence"){
n <- ncol(pam$P)
species <- pam$S
pam2 <- pam$P
}else{
n <- ncol(pam)
species <- colnames(pam)[-(1:2)]
pam2 <- pam
}
xm <- numeric((n-2))
ym <- numeric((n-2))
for(i in 3:n){
pos <- which(pam2[,i]==1)
a <- max(pam2[pos, 1])
b <- min(pam2[pos, 1])
c <- max(pam2[pos, 2])
d <- min(pam2[pos, 2])
if(planar==F){
dis2 <- midPoint(c(a,c), c(b,d))
if(length(pam2[pos, 1])>1){
dis <- geomean(cbind(pam2[pos, 1], pam2[pos, 2]))
dif <- distCosine(c(dis[1, 1], 0), c(dis2[1, 1],0))/(111.321*1000)
if(dif>150){
print(i)
if(dis2[1, 1]>=0){
dis2[1, 1] <- dis2[1, 1]-180
}else{
dis2[1, 1] <- dis2[1, 1]+180
}
}
}
xm[(i-2)] <- dis2[1, 1]
ym[(i-2)] <- dis2[1, 2]
}
if(planar==T){
xm[(i-2)] <- mean(c(a,b))
ym[(i-2)] <- mean(c(c,d))
}
}
resu <- as.data.frame(cbind(species, xm, ym))
colnames(resu) <- c("Species", "x", "y")
resu[, 2] <- as.numeric(levels(resu[, 2]))[resu[, 2]]
resu[, 3] <- as.numeric(levels(resu[, 3]))[resu[, 3]]
return(resu)
}
library(letsR)
library(maptools)
library(raster)
#Packages
library(raster)
library(maptools)
library(maps)
library(XML)
#Shapes
serpe <- readShapePoly("C:/Users/Bruno/SkyDrive/Pacote/SEASNAKES/VIEW_SEASNAKES.shp")
resu <- lets.presab(serpe, resol=1, remove.cell=T, count=T)
library(raster)
library(maptools)
library(maps)
library(XML)
library(geosphere)
library(letsR)
serpe <- readShapePoly("C:/Users/Bruno/SkyDrive/Pacote/SEASNAKES/VIEW_SEASNAKES.shp")
resu <- lets.presab(serpe, resol=1, remove.cell=T, remove.sp=T, count=T)
plot(resu)
plot(resu, name="Pelamis platura")
plot(resu)
plot(resu, name="Pelamis platura")
getExtent()
drawExtent()
?lets.presab
resu <- lets.presab(serpe, resol=1, remove.cell=T, remove.sp=T, count=T,  xmn=-122, xmx=-61.7, ymn=-21.1, ymx=37.9)
warnings()
plot(serpe)
plot(resu)
resu
seu$S
resu$S
summary(rseu)
summary(resu)
head(resu$P)
library(letsR)
resu <- lets.presab(serpe, resol=1, remove.cell=T, remove.sp=T, count=T,  xmn=-122, xmx=-61.7, ymn=-21.1, ymx=37.9)
resu$S
colnames(resu$P)
colnames(resu$P)[,-(1:2)]
colnames(resu$P[,-(1:2)])
colnames(resu$P)[(1:2)]
colnames(resu$P)[-(1:2)]
#' Shapefiles to presence/absence matrix
#'
#' @author Bruno Vilela & Fabricio Villalobos
#'
#' @description Transform species shapefiles into a matrix of presence/absence.
#'
#' @usage lets.presab(shapes, xmn=-180, xmx=180, ymn=-90, ymx=90, resol=1,
#' remove.cells=TRUE, remove.sp=TRUE, show.matrix=FALSE,
#' crs=CRS("+proj=longlat +datum=WGS84"), cover=0, presence=NULL,
#' origin=NULL, seasonal=NULL, count=FALSE)
#'
#' @param shapes SpatialPolygonsDataFrame (see function readShapePoly to open these files) class object. Species name should be in a subclass called BINOMIAL or binomial.
#' @param xmx Maximun longitude used to construct the grid of cells in which the matrix will be based.
#' @param xmn Minimun longitude used to construct the grid of cells in which the matrix will be based.
#' @param ymx Maximun latitude used to construct the grid of cells in which the matrix will be based.
#' @param ymn Minimun latitude used to construct the grid of cells in which the matrix will be based.
#' @param remove.cells If true, the final matrix will not contain cells in the grid with a value equal to zero.
#' @param remove.sp If true, the final matrix will not contain species that do not match any cell in the grid.
#' @param show.matrix if true, only the object matrix will be shown.
#' @param crs the projection of the shapefiles.
#' @param cover Porcentage of the cell covered by the shapefile that shall be considered for presence (values between 0 and 1).
#' @param count Logical, if TRUE a counting window will be open.
#'
#'
#' @return The result is an object of class PresenceAbsence with the following objects:
#' @return Presence and Absence Matrix: A matrix of Presence(1) and Absence(0) with x (longitude) and y (latitude) of cells centroid;
#' @return Richness Raster: A raster containing richness data;
#' @return Species name: A vector with species names that are in the matrix.
#' @return *But see the option argument show.matrix.
#'
#'
#' @details The function creates the matrix of presence/absence based on a raster file. Depending on the cell size, extension used and number of species it may require a lot of memmory,
#'and may take some time to process it. Because of this, during the process we open a counting window so you can see in what polygon the function is working. Note that the number of
#'polygons is not the same number of species that you have. Before run the function please check if the arguments are in the way you want.
#'
#' @seealso plot.PresenceAbsence
#' @seealso lets.presab.birds
#' @seealso lets.shFilter
#'
#' @import raster
#' @import maptools
#' @import maps
#'
#' @export
lets.presab <- function(shapes, xmn=-180, xmx=180, ymn=-90,
ymx=90, resol=1, remove.cells=TRUE,
remove.sp=TRUE, show.matrix=FALSE,
crs=CRS("+proj=longlat +datum=WGS84"),
cover=0, presence=NULL, origin=NULL,
seasonal=NULL, count=FALSE){
shapes <- lets.shFilter(shapes, presence=presence, origin=origin, seasonal=seasonal)
if(is.null(shapes)){
stop("after filtering none species distribution left")
}
ras <- raster(xmn=xmn, xmx=xmx, ymn=ymn, ymx=ymx, crs=crs)
res(ras) <- resol
values(ras) <- 1
coord <- xyFromCell(ras, 1:length(values(ras)))
colnames(coord) <- c("Longitude(x)", "Latitude(y)")
if(any(names(shapes)=="BINOMIAL")){
nomes <- levels(shapes$BINOMIAL)
n <- length(shapes$BINOMIAL)
nomes2 <- shapes$BINOMIAL
}
if(any(names(shapes)=="binomial")){
nomes <- levels(shapes$binomial)
n <- length(shapes$binomial)
nomes2 <- shapes$binomial
}
matriz <- matrix(0, ncol=length(nomes), nrow=length(values(ras)))
colnames(matriz) <- nomes
if(count == TRUE){
x11(2, 2, pointsize = 12)
par(mar=c(0, 0, 0, 0))
for(i in 1:n){
plot.new()
text(0.5, 0.5, paste(paste("Total:", n, "\n","Runs to go: ", (n-i))))
celulas <- extract(ras, SpatialPolygons(list(shapes@polygons[[i]])), cellnumbers=T, weights=T, small=T)
pos <- which(nomes2[i]==nomes)
pos2 <- do.call(rbind.data.frame, celulas)
pos2 <- pos2[which(pos2[,3]>=cover), ]
matriz[pos2[, 1], pos] <- 1
}
dev.off()
}
if(count == FALSE){
for(i in 1:n){
celulas <- extract(ras, SpatialPolygons(list(shapes@polygons[[i]])), cellnumbers=T, weights=T, small=T)
pos <- which(nomes2[i]==nomes)
pos2 <- do.call(rbind.data.frame, celulas)
pos2 <- pos2[which(pos2[,3]>=cover), ]
matriz[pos2[, 1], pos] <- 1
}
}
cbind(coord,matriz)->Resultado
if(remove.cells==TRUE){
Resultado <- .removeCells(Resultado)
}
if(remove.sp==TRUE){
Resultado <- .removeSp(Resultado)
}
if(show.matrix==TRUE){
return(Resultado)
}else{
values(ras) <- rowSums(matriz)
final <- list("Presence and Absence Matrix"=Resultado, "Richness Raster"=ras,
"Species name"=colnames(Resultado)[-(1:2)])
class(final) <- "PresenceAbsence"
return(final)
}
}
resu <- lets.presab(serpe, resol=1, remove.cell=T, remove.sp=T, count=T,  xmn=-122, xmx=-61.7, ymn=-21.1, ymx=37.9)
resu
summary(resu)
resu$S
colnames(resu$P)[-(1:2)]
#' Shapefiles to presence/absence matrix
#'
#' @author Bruno Vilela & Fabricio Villalobos
#'
#' @description Transform species shapefiles into a matrix of presence/absence.
#'
#' @usage lets.presab(shapes, xmn=-180, xmx=180, ymn=-90, ymx=90, resol=1,
#' remove.cells=TRUE, remove.sp=TRUE, show.matrix=FALSE,
#' crs=CRS("+proj=longlat +datum=WGS84"), cover=0, presence=NULL,
#' origin=NULL, seasonal=NULL, count=FALSE)
#'
#' @param shapes SpatialPolygonsDataFrame (see function readShapePoly to open these files) class object. Species name should be in a subclass called BINOMIAL or binomial.
#' @param xmx Maximun longitude used to construct the grid of cells in which the matrix will be based.
#' @param xmn Minimun longitude used to construct the grid of cells in which the matrix will be based.
#' @param ymx Maximun latitude used to construct the grid of cells in which the matrix will be based.
#' @param ymn Minimun latitude used to construct the grid of cells in which the matrix will be based.
#' @param remove.cells If true, the final matrix will not contain cells in the grid with a value equal to zero.
#' @param remove.sp If true, the final matrix will not contain species that do not match any cell in the grid.
#' @param show.matrix if true, only the object matrix will be shown.
#' @param crs the projection of the shapefiles.
#' @param cover Porcentage of the cell covered by the shapefile that shall be considered for presence (values between 0 and 1).
#' @param count Logical, if TRUE a counting window will be open.
#'
#'
#' @return The result is an object of class PresenceAbsence with the following objects:
#' @return Presence and Absence Matrix: A matrix of Presence(1) and Absence(0) with x (longitude) and y (latitude) of cells centroid;
#' @return Richness Raster: A raster containing richness data;
#' @return Species name: A vector with species names that are in the matrix.
#' @return *But see the option argument show.matrix.
#'
#'
#' @details The function creates the matrix of presence/absence based on a raster file. Depending on the cell size, extension used and number of species it may require a lot of memmory,
#'and may take some time to process it. Because of this, during the process we open a counting window so you can see in what polygon the function is working. Note that the number of
#'polygons is not the same number of species that you have. Before run the function please check if the arguments are in the way you want.
#'
#' @seealso plot.PresenceAbsence
#' @seealso lets.presab.birds
#' @seealso lets.shFilter
#'
#' @import raster
#' @import maptools
#' @import maps
#'
#' @export
lets.presab <- function(shapes, xmn=-180, xmx=180, ymn=-90,
ymx=90, resol=1, remove.cells=TRUE,
remove.sp=TRUE, show.matrix=FALSE,
crs=CRS("+proj=longlat +datum=WGS84"),
cover=0, presence=NULL, origin=NULL,
seasonal=NULL, count=FALSE){
shapes <- lets.shFilter(shapes, presence=presence, origin=origin, seasonal=seasonal)
if(is.null(shapes)){
stop("after filtering none species distribution left")
}
ras <- raster(xmn=xmn, xmx=xmx, ymn=ymn, ymx=ymx, crs=crs)
res(ras) <- resol
values(ras) <- 1
coord <- xyFromCell(ras, 1:length(values(ras)))
colnames(coord) <- c("Longitude(x)", "Latitude(y)")
if(any(names(shapes)=="BINOMIAL")){
nomes <- levels(shapes$BINOMIAL)
n <- length(shapes$BINOMIAL)
nomes2 <- shapes$BINOMIAL
}
if(any(names(shapes)=="binomial")){
nomes <- levels(shapes$binomial)
n <- length(shapes$binomial)
nomes2 <- shapes$binomial
}
matriz <- matrix(0, ncol=length(nomes), nrow=length(values(ras)))
colnames(matriz) <- nomes
if(count == TRUE){
x11(2, 2, pointsize = 12)
par(mar=c(0, 0, 0, 0))
for(i in 1:n){
plot.new()
text(0.5, 0.5, paste(paste("Total:", n, "\n","Runs to go: ", (n-i))))
celulas <- extract(ras, SpatialPolygons(list(shapes@polygons[[i]])), cellnumbers=T, weights=T, small=T)
pos <- which(nomes2[i]==nomes)
pos2 <- do.call(rbind.data.frame, celulas)
pos2 <- pos2[which(pos2[,3]>=cover), ]
matriz[pos2[, 1], pos] <- 1
}
dev.off()
}
if(count == FALSE){
for(i in 1:n){
celulas <- extract(ras, SpatialPolygons(list(shapes@polygons[[i]])), cellnumbers=T, weights=T, small=T)
pos <- which(nomes2[i]==nomes)
pos2 <- do.call(rbind.data.frame, celulas)
pos2 <- pos2[which(pos2[,3]>=cover), ]
matriz[pos2[, 1], pos] <- 1
}
}
cbind(coord,matriz)->Resultado
if(remove.cells==TRUE){
Resultado <- .removeCells(Resultado)
}
if(remove.sp==TRUE){
Resultado <- .removeSp(Resultado)
}
if(show.matrix==TRUE){
return(Resultado)
}else{
values(ras) <- rowSums(matriz)
final <- list("Presence and Absence Matrix"=Resultado, "Richness Raster"=ras,
"Species name"=colnames(Resultado)[-(1:2)])
class(final) <- "PresenceAbsence"
return(final)
}
}
resu <- lets.presab(serpe, resol=1, remove.cell=T, remove.sp=T, count=T,  xmn=-122, xmx=-61.7, ymn=-21.1, ymx=37.9)
warnings()
summary(resu1)
summary(resu)
rm(lets.presab)
library(devtools)
install_github("BrunoVilela/letsR")
library(letsR)
lets.presab
resu <- lets.presab(serpe, resol=2, remove.cell=T, remove.sp=T, count=T,  xmn=-122, xmx=-61.7, ymn=-21.1, ymx=37.9)
resu
summary(resu)
resu$S
plot(resu)
